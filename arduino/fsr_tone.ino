// -*- Mode:c -*-
// The above incantation tells emacs to do C style syntax highlighting

/* Use FSR to create a sound on the WAVE Shield

Add the WAVE Shield (we used version 1.1) to the Arduino 
(we used the Arduino Uno)

Connect the WaveShield digital pins as described here (the second-to-last panel):
http://www.ladyada.net/make/waveshield/solder.html

Connect one end of FSR to 5V, the other end to Analog 0.
Then connect one end of a 10K resistor from Analog 0 to ground

For more information see http://www.ladyada.net/learn/sensors/fsr.html
and http://www.ladyada.net/make/waveshield/examples.html
*/

////////////////////////////////////  set variables 
int fsrAnalogPin = 0; // FSR is connected to analog 0
int fsrReading;      // the analog reading from the FSR resistor divider
int threshold = 5; // the FSR threshold necessary to make a sound (ON)
int low_thresh = 2; // where the FSR reading must go to to be OFF
int time_thresh = 40; // set a time threshold for how long to wait until another sound can be made
int offset_thresh = 40; // set a time threshold for how long to wait after depression (prevent double taps)
char* beginRead = "B"; // gives a start read barrier for the FSR reading
char* endRead = "E"; // gives an end read barrier for the FSR reading
int tone_freq = 440;
int tone_dur = 20;



unsigned long time_tol = 0; // preset the exact time from which it is ok to make another sound
unsigned long timeStamp=0; // timestamp for Arduino
unsigned long prevt=-1; // the previous time value to ensure sample rate of 1000Hz
unsigned long tone_tol=0; // the previous time value to ensure sample rate of 1000Hz



/////////////////////////////// Set up lookup table for waveform generation


/*
A square wave lookup table. You can generate this using the example Python code here below:
sqwav = [ '0xff' for _ in range(256/2) ] + [ '0x00' for _ in range(256/2) ]
print ",".join(sqwav)
*/

static const uint8_t  sineTable[] PROGMEM =
{
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};


/* A 256-item lookup table for a sine wave. Each item is encoded as a hexadecimal number, hence the 0x prefix */
/*static const uint8_t  sineTable[] PROGMEM =
{
0x80,0x83,0x86,0x89,0x8c,0x8f,0x92,0x95,
0x98,0x9c,0x9f,0xa2,0xa5,0xa8,0xab,0xae,
0xb0,0xb3,0xb6,0xb9,0xbc,0xbf,0xc1,0xc4,
0xc7,0xc9,0xcc,0xce,0xd1,0xd3,0xd5,0xd8,
0xda,0xdc,0xde,0xe0,0xe2,0xe4,0xe6,0xe8,
0xea,0xec,0xed,0xef,0xf0,0xf2,0xf3,0xf5,
0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfc,
0xfd,0xfe,0xfe,0xff,0xff,0xff,0xff,0xff,
0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0xfe,
0xfd,0xfc,0xfc,0xfb,0xfa,0xf9,0xf8,0xf7,
0xf6,0xf5,0xf3,0xf2,0xf0,0xef,0xed,0xec,
0xea,0xe8,0xe6,0xe4,0xe2,0xe0,0xde,0xdc,
0xda,0xd8,0xd5,0xd3,0xd1,0xce,0xcc,0xc9,
0xc7,0xc4,0xc1,0xbf,0xbc,0xb9,0xb6,0xb3,
0xb0,0xae,0xab,0xa8,0xa5,0xa2,0x9f,0x9c,
0x98,0x95,0x92,0x8f,0x8c,0x89,0x86,0x83,
0x80,0x7c,0x79,0x76,0x73,0x70,0x6d,0x6a,
0x67,0x63,0x60,0x5d,0x5a,0x57,0x54,0x51,
0x4f,0x4c,0x49,0x46,0x43,0x40,0x3e,0x3b,
0x38,0x36,0x33,0x31,0x2e,0x2c,0x2a,0x27,
0x25,0x23,0x21,0x1f,0x1d,0x1b,0x19,0x17,
0x15,0x13,0x12,0x10,0x0f,0x0d,0x0c,0x0a,
0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x03,
0x02,0x01,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,
0x02,0x03,0x03,0x04,0x05,0x06,0x07,0x08,
0x09,0x0a,0x0c,0x0d,0x0f,0x10,0x12,0x13,
0x15,0x17,0x19,0x1b,0x1d,0x1f,0x21,0x23,
0x25,0x27,0x2a,0x2c,0x2e,0x31,0x33,0x36,
0x38,0x3b,0x3e,0x40,0x43,0x46,0x49,0x4c,
0x4f,0x51,0x54,0x57,0x5a,0x5d,0x60,0x63,
0x67,0x6a,0x6d,0x70,0x73,0x76,0x79,0x7c
};
*/


/*
A saw wave

static const uint8_t  sineTable[] PROGMEM =
{
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
};

*/

// PWM output (OCR1A)
int pwmPin = 9;

// 16 bit accumulator
uint16_t phaseAccumulator = 0;
// 16 bit delta
uint16_t phaseIncrement = 0;
// DDS resolution
const uint32_t resolution =  68719;
// wavetable lookup index(upper 8 bits of the accumulator)
uint8_t index = 0;
// Desired output frequency (let's set it to 440Hz)
uint16_t frequency = 440;

// TIMER1 will overflow at a 62.5KHz(Sampling frequency).
// Updates the OCR1A value and the accumulator.
// Computes the next sample to be sent to the PWM.
ISR(TIMER1_OVF_vect)
{
  static uint8_t osc = 0;

  // Send oscillator output to PWM
  OCR1A = osc;

  // Update accumulator
  phaseAccumulator += phaseIncrement;
  index = phaseAccumulator >> 8;

  // Read oscillator value for next interrupt
  osc = pgm_read_byte( &sineTable[index] );

}

// Configures TIMER1 to fast PWM non inverted mode.
// Prescaler set to 1, which means that timer overflows
// every 16MHz/256 = 62.5KHz
void initPWM(void)
{
  // Set PORTB1 pin as output
  pinMode(pwmPin, OUTPUT);

  // 8-bit Fast PWM - non inverted PWM
  TCCR1A= _BV(COM1A1) | _BV(WGM10);

  // Start timer without prescaler
  TCCR1B = _BV(CS10) | _BV(WGM12);

  // Enable overflow interrupt for OCR1A
  TIMSK1 = _BV(TOIE1);

}

// Translates the desired output frequency to a phase
// increment to be used with the phase accumulator.
// The 16 bit shift is required to remove the  2^16
// scale factor of the resolution.
void setFrequency( uint16_t frequency )
{
  uint64_t phaseIncr64 =  resolution * frequency;
  phaseIncrement = phaseIncr64 >> 16;
}

// The duration of one metronome tick (in microsec)
const unsigned long TICKDURATION = 20000;   // 10msec

void tickOn(){
  setFrequency(tone_freq);
}


void tickOff() {
  setFrequency( .05 ); // so that you practically don't hear anything
}

//////////////////////////////////// load libraries
//#include <WaveHC.h>
//#include <WaveUtil.h>
#include <avr/pgmspace.h>
#include <avr/sleep.h>

//////////////////////////////////// set objects
//SdReader card;    // This object holds the information for the card
//FatVolume vol;    // This holds the information for the partition on the card
//FatReader root;   // This holds the information for the volumes root directory
//FatReader file;   // This object represent the WAV file 
//WaveHC wave;      // This is the only wave (audio) object, since we1 will o1nly pla1y one at a time

//////////////////////////////////// Define macro to put error messages in flash memory
#define error(msg) error_P(PSTR(msg))

//////////////////////////////////// SETUP
void setup() {
  //Serial.begin(9600); // slow speed debugging
  //Serial.begin(115200); // high speed debugging
  Serial.begin(1555200); // good speed for processing
  
  // Initialise fast PWM
  initPWM();

  // Enable sleep mode
  set_sleep_mode(SLEEP_MODE_IDLE);

  // Set phase increment according to
  // desired output frequency
  tickOff();

  // Enable global interrupts
  sei();

  //if (!card.init()) error("card.init");

  // enable optimized read - some cards may timeout
  //card.partialBlockRead(true);

  //if (!vol.init(card)) error("vol.init");

  //if (!root.openRoot(vol)) error("openRoot");
  
  // Set the output pins for the DAC control. This pins are defined in the library
  // This is for the Wave shield output
  //pinMode(2, OUTPUT);
  //pinMode(3, OUTPUT);
  //pinMode(4, OUTPUT);
  //pinMode(5, OUTPUT);
  
// look in the root directory and open the file
  //if (!file.open(root, wavFile)) {
  //  putstring("Couldn't open file "); Serial.print(wavFile); return;
  //}
  // OK read the file and turn it into a wave object
  //if (!wave.create(file)) {
  //  putstring_nl("Not a valid WAV"); return;
  //}

  //file.open(root, wavFile);
  //wave.create(file);
 
}

//////////////////////////////////// LOOP
void loop(void) {
  getInfos();  
  collectData();
  
  if (fsrReading > threshold){

    time_tol = timeStamp+time_thresh;

    // play the wav file
    tickOn();
    tone_tol = timeStamp+tone_dur;
    //playcomplete(wavFile); 
    
    getInfos();
    collectData();
    
    // now let's stop it from playing again before the reading returns to zero    
    while ((fsrReading > low_thresh) || (timeStamp < time_tol))  {
      getInfos();
      collectData();     
      
    }
  
    time_tol = timeStamp+offset_thresh;
    
    while   ((fsrReading > low_thresh) || (timeStamp < time_tol))  {      
      getInfos();
      collectData();      
   }
   
  }
     
}

//////////////////////////////////// FUNCTIONS

// Plays a full file from beginning to end with no pause.
//void playcomplete(char *name) {
  //getInfos();
  //collectData();
  // call our helper to find and play this name
  //playfile(name);
  //while (wave.isplaying) {
  // collect data while it is playing (because otherwise it blocks the readings)
  //getInfos();
  //collectData();    
  //}
  //getInfos();
  //collectData();  
  // open and create wavefile for next read
  //file.open(root, name);
  //wave.create(file);
//}

//void playfile(char *name) {
  // see if the wave object is currently doing something
  //if (wave.isplaying) {// already playing something, so stop it!
    //wave.stop(); // stop it
  //}  
  //getInfos();
  //collectData();
  // start playback
  //wave.play();
//}

void collectData() { 
      
  if (prevt==-1 | timeStamp!=prevt) { 
    // only send if the time has changed, that is, 
    // force the data transfer to maximum of 1000Hz.
    // Using higher sample rates can result in buffer
    // overflows and missed packets

    // Send data to the serial port (for degugging)
    //Serial.print("FSR = ");
    //Serial.print(fsrReading);
    //Serial.print("Time = ");
    //Serial.print(timeStamp);
    //Serial.print("\n");
    
    // Send data to the serial port
    Serial.print("B");    
    sendBinary(timeStamp);
    sendBinary(fsrReading);
    Serial.print("E");    
    prevt=timeStamp;  
  }    
}

void getInfos() {
  fsrReading = analogRead(fsrAnalogPin); // read FSR
  timeStamp = millis(); // get time (in milliseconds)       
  if (timeStamp>=tone_tol) tickOff();
}

void sendBinary(int value) 
// Send a binary value directly (without conversion to string)
// based on http://my.safaribooksonline.com/book/hobbies/9781449399368/serial-communications/sending_binary_data_from_arduino#X2ludGVybmFsX0ZsYXNoUmVhZGVyP3htbGlkPTk3ODE0NDkzOTkzNjgvMTAy
{
  Serial.write(lowByte(value));
  Serial.write(highByte(value));
}


/////////////////////////////////// HELPERS
/*
 * print error message and halt
 */
//void error_P(const char *str) {
  //PgmPrint("Error: ");
  //SerialPrint_P(str);
  //sdErrorCheck();
  //while(1);
//}
/*
 * print error message and halt if SD I/O error, great for debugging!
 */
//void sdErrorCheck(void) {
  //if (!card.errorCode()) return;
  //PgmPrint("\r\nSD I/O error: ");
  //Serial.print(card.errorCode(), HEX);
  //PgmPrint(", ");
  //Serial.println(card.errorData(), HEX);
  //while(1);
//}


